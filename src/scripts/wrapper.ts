/**
 * Main build wrapper - Orchestrates version generation and build process
 */

import * as path from 'path';
import * as fs from 'fs';
import { execSync } from 'child_process';
import { readConfig } from '../utils/config-reader';
import { Logger } from '../utils/logger';
import { ReactScriptsAdapter } from './adapters/react-scripts';
import { ViteAdapter } from './adapters/vite';
import { WebpackAdapter } from './adapters/webpack';
import { BuildAdapter } from './adapters/base';
import { VERSION_FILE_NAME } from '../constants/defaults';
import { AppVersion } from '../types/config';

const logger = new Logger();

/**
 * Get the appropriate adapter based on config
 */
function getAdapter(adapterName: string): BuildAdapter {
  switch (adapterName) {
    case 'react-scripts':
      return new ReactScriptsAdapter();
    case 'vite':
      return new ViteAdapter();
    case 'webpack':
      return new WebpackAdapter();
    default:
      throw new Error(`Unknown adapter: ${adapterName}`);
  }
}

/**
 * Generate a simple build hash
 */
function generateBuildId(): string {
  try {
    const gitHash = execSync('git rev-parse --short HEAD').toString().trim();

    // Check for uncommitted changes
    try {
      const status = execSync('git status --porcelain').toString().trim();
      if (status) {
        // If dirty, confirm we want a unique ID relative to the previous build
        return `${gitHash}-dirty-${Date.now().toString(36)}`;
      }
    } catch (e) {
      // Ignore status check error
    }

    return gitHash;
  } catch (error) {
    // Fallback if git is not available
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }
}

/**
 * Get the latest git commit author
 */
function getGitAuthor(): string | null {
  try {
    return execSync('git log -1 --format=%an').toString().trim();
  } catch (error) {
    return null;
  }
}

/**
 * Get the latest git commit message
 */
function getGitCommitMessage(): string | null {
  try {
    return execSync('git log -1 --format=%s').toString().trim();
  } catch (error) {
    return null;
  }
}

/**
 * Get package version from package.json
 */
function getPackageVersion(): string {
  try {
    const packageJsonPath = path.join(process.cwd(), 'package.json');
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
    return packageJson.version || '0.0.0';
  } catch (error) {
    logger.warn('Could not read package.json version, using 0.0.0');
    return '0.0.0';
  }
}

/**
 * Write version.ts to src directory
 */
function writeSourceVersionFile(versionData: AppVersion): void {
  const srcDir = path.join(process.cwd(), 'src');
  const versionFilePath = path.join(srcDir, 'version.ts');

  if (!fs.existsSync(srcDir)) {
    fs.mkdirSync(srcDir, { recursive: true });
  }

  const fileContent = `// Auto-generated by @thisisayande/rzd build process
export const CURRENT_VERSION = '${versionData.version}';
export const CURRENT_BUILD_ID = '${versionData.buildId}';
export const CURRENT_AUTHOR = ${versionData.commitAuthor ? `'${versionData.commitAuthor}'` : 'null'};
export const CURRENT_COMMIT_MESSAGE = ${versionData.commitMessage ? `'${versionData.commitMessage.replace(/'/g, "\\'")}'` : 'null'};
export const CURRENT_BUILD_TIME = '${new Date(versionData.timestamp).toISOString()}';
`;

  fs.writeFileSync(versionFilePath, fileContent, 'utf-8');
  logger.success(`Updated source version file: ${versionFilePath}`);
}

/**
 * Generate version file in output directory
 */
function generateVersionFile(outputDir: string, versionData: AppVersion): void {
  const versionFilePath = path.join(outputDir, VERSION_FILE_NAME);

  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(
    versionFilePath,
    JSON.stringify(versionData, null, 2),
    'utf-8'
  );

  logger.success(`Generated output version file: ${versionFilePath}`);
  logger.info(`Version: ${versionData.version}, Build ID: ${versionData.buildId}`);
}

/**
 * Recursive copy function to merge directories
 */
function copyRecursive(src: string, dest: string): void {
  const stats = fs.statSync(src);
  if (stats.isDirectory()) {
    if (!fs.existsSync(dest)) {
      fs.mkdirSync(dest, { recursive: true });
    }

    const files = fs.readdirSync(src);
    for (const file of files) {
      copyRecursive(path.join(src, file), path.join(dest, file));
    }
  } else {
    fs.copyFileSync(src, dest);
  }
}

/**
 * Main build wrapper function
 */
export async function buildWrapper(): Promise<void> {
  let tempOutputDir: string | null = null;

  try {
    logger.log('ðŸš€ React Zero Downtime Build - Starting...');

    // Read configuration
    const config = readConfig();
    logger.info('Configuration loaded:', config);

    // Get the appropriate adapter
    const adapter = getAdapter(config.adapter);

    // Validate the adapter
    if (!adapter.validate()) {
      throw new Error(
        `${adapter.name} adapter validation failed. ` +
        `Make sure ${adapter.name} is installed in your project.`
      );
    }

    logger.log(`Using ${adapter.name} adapter`);

    // Prepare version data
    const packageVersion = getPackageVersion();
    const buildId = generateBuildId();
    const commitAuthor = getGitAuthor();
    const commitMessage = getGitCommitMessage();

    const versionData: AppVersion = {
      version: packageVersion,
      timestamp: Date.now(),
      buildId: buildId,
      commitAuthor: commitAuthor,
      commitMessage: commitMessage,
    };

    // 1. Write src/version.ts BEFORE build so it gets bundled
    logger.log('Updating source version...');
    writeSourceVersionFile(versionData);

    // 2. Prepare directories
    const finalOutputDir = adapter.getOutputDir(config);
    tempOutputDir = path.join(process.cwd(), '.rzd_temp_build');

    // Clean temp dir if it exists
    if (fs.existsSync(tempOutputDir)) {
      fs.rmSync(tempOutputDir, { recursive: true, force: true });
    }

    // 3. Execute the build into temp directory
    logger.log(`Building application into temporary directory...`);
    await adapter.build(config, tempOutputDir);

    // 4. Generate version file in the TEMP directory
    // We do this before merging so it's part of the atomic update
    generateVersionFile(tempOutputDir, versionData);

    // 5. Merge temp build into final output directory
    logger.log(`Merging build into ${finalOutputDir} (preserving old files)...`);

    // Ensure final output dir exists
    if (!fs.existsSync(finalOutputDir)) {
      fs.mkdirSync(finalOutputDir, { recursive: true });
    }

    copyRecursive(tempOutputDir, finalOutputDir);

    logger.success('âœ… React Zero Downtime Build - Complete!');
    logger.info(`Version: ${versionData.version}, Build ID: ${versionData.buildId}`);

  } catch (error) {
    logger.error('Build failed:', error);
    process.exit(1);
  } finally {
    // Cleanup temp directory
    if (tempOutputDir && fs.existsSync(tempOutputDir)) {
      try {
        fs.rmSync(tempOutputDir, { recursive: true, force: true });
      } catch (e) {
        logger.warn('Failed to clean up temporary directory');
      }
    }
  }
}

// Run if executed directly
if (require.main === module) {
  buildWrapper();
}
